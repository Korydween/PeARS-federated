# SPDX-FileCopyrightText: 2023 PeARS Project, <community@pearsproject.org>,
#
# SPDX-License-Identifier: AGPL-3.0-only

# Import flask dependencies
from os.path import dirname, join, realpath
from flask import Blueprint, request, render_template, url_for
from flask_login import login_required, current_user
from app.auth.decorators import check_is_confirmed
from app import LANG, OWN_BRAND
from app.api.models import Urls
from app.indexer import mk_page_vector
from app.utils import read_urls, parse_query
from app.utils_db import (create_idx_to_url, create_pod_in_db, create_pod_npz_pos,
        add_to_idx_to_url, add_to_npz_to_idx, create_or_replace_url_in_db)
from app.indexer.access import request_url
from app.indexer.posix import posix_doc
from app.forms import IndexerForm, ManualEntryForm

app_dir_path = dirname(dirname(realpath(__file__)))
suggestions_dir_path = join(app_dir_path,'static', 'userdata')

# Define the blueprint:
indexer = Blueprint('indexer', __name__, url_prefix='/indexer')

@indexer.context_processor
def inject_brand():
    """Inject brand information into page
    (logo on all pages and info on start page.)
    """
    return dict(own_brand=OWN_BRAND)


@indexer.route("/", methods=["GET"])
@login_required
@check_is_confirmed
def index():
    """Displays the indexer page.
    Computes and returns the total number
    of URLs in the entire instance. Passes
    online and offline suggestion forms to
    the indexer template.
    """
    num_db_entries = len(Urls.query.all())
    form1 = IndexerForm(request.form)
    form2 = ManualEntryForm(request.form)
    return render_template("indexer/index.html", \
            num_entries=num_db_entries, form1=form1, form2=form2)



@indexer.route("/url", methods=["POST"])
@login_required
@check_is_confirmed
def index_from_url():
    """ Route for URL entry form.
    This is to index a URL that the user
    has suggested through the IndexerForm.
    Validates the suggestion form and calls the
    indexer (progres_file).
    """
    print("\t>> Indexer : from_url")
    contributor = current_user.username
    create_idx_to_url(contributor)

    form = IndexerForm(request.form)
    if form.validate_on_submit():
        user_url_file = join(suggestions_dir_path, contributor+".suggestions")
        url = request.form.get('url')
        theme = request.form.get('theme')
        trigger = request.form.get('trigger')
        theme, _, lang = parse_query(theme)
        if trigger is None:
            trigger = ''
        print(url, theme, lang, trigger, contributor)
        with open(user_url_file, 'w', encoding="utf-8") as f:
            f.write(url + ";" + theme + ";" + lang + ";" + trigger + ";" + contributor + "\n")
        print("\t>> Indexer : progress_file")
        messages = run_indexer_url(contributor, user_url_file)
        return render_template('indexer/progress_file.html', messages = messages)
    return render_template('indexer/index.html', form1=form, form2=ManualEntryForm(request.form))



@indexer.route("/manual", methods=["POST"])
@login_required
@check_is_confirmed
def index_from_manual():
    """ Route for manual (offline) entry form.
    This is to index offline tips that the user
    may want to share on the instance.
    Validates the ManualEntryForm and calls the
    indexer (manual_progres_file).
    """
    print("\t>> Indexer : manual")
    contributor = current_user.username
    create_idx_to_url(contributor)

    form = ManualEntryForm(request.form)
    if form.validate_on_submit():
        title = request.form.get('title')
        snippet = request.form.get('description')
        u = url_for('search.index',q=' '.join(snippet.split()[:4]))
        trigger = ''
        keyword = 'Tips'
        print(u, keyword, LANG, trigger, contributor)
        print("\t>> Indexer : manual_progress_file")
        messages = run_indexer_manual(u, title, snippet, keyword, LANG, trigger, contributor)
        return render_template('indexer/progress_file.html', messages=messages)
    return render_template('indexer/index.html', form1=IndexerForm(request.form), form2=form)



def run_indexer_url(contributor, user_url_file):
    """ Run the indexer over the suggested URL.
    This includes checking the robots.txt, and producing 
    representations that include entries in the positional
    index as well as vectors. A new entry is also
    added to the database.

    Arguments: a username and the file containing the
    information provided by the user about the URL to
    index (auto-generated by 'index_from_url').
    """
    print(">> INDEXER: run_indexer_url: Running indexer over suggested URL.")
    messages = []
    urls, themes, langs, triggers, contributors, errors = read_urls(user_url_file)
    if errors:
        return errors
    if not urls or not themes or not langs:
        messages.append('ERROR: Invalid file format.')
        return messages
    theme = themes[0]
    create_pod_npz_pos(contributor, theme)
    create_pod_in_db(contributor, theme, LANG)
    for url, theme, lang, trigger, _ in zip(urls, themes, langs, triggers, contributors):
        access, req, request_errors = request_url(url)
        if access:
            try:
                url_type = req.headers['Content-Type']
            except:
                messages.append('ERROR: Content type could not be retrieved from header.')
                continue
            idx = add_to_idx_to_url(contributor, url)
            success, text, title, snippet, vid, mgs = \
                    mk_page_vector.compute_vector(url, theme, lang, contributor, url_type)
            if success:
                posix_doc(text, idx, contributor, theme)
                add_to_npz_to_idx(theme+'.u.'+contributor, vid, idx)
                create_or_replace_url_in_db(\
                        url, title, snippet, theme, lang, trigger, contributor, 'url')
                success_message = url+" was successfully indexed."
                messages.append(success_message)
            else:
                messages.extend(mgs)
        else:
            messages.extend(request_errors)
    return messages


def run_indexer_manual(url, title, doc, theme, lang, trigger, contributor):
    """ Run the indexer over manually contributed information.
    
    Arguments: a url (internal and bogus, constructed by 'index_from_manual'),
    the title and content of the added document, a topic, language, trigger 
    information, as well as the username of the contributor.
    """
    print(">> INDEXER: run_indexer_manual: Running indexer over manually added information.")
    messages = []
    create_pod_npz_pos(contributor, theme)
    create_pod_in_db(contributor, theme, LANG)
    idx = add_to_idx_to_url(contributor, url)
    text, snippet, vid = mk_page_vector.compute_vector_local_docs(\
            title, doc, theme, lang, contributor)
    posix_doc(text, idx, contributor, theme)
    add_to_npz_to_idx(theme+'.u.'+contributor, vid, idx)
    create_or_replace_url_in_db(url, title, snippet, theme, lang, trigger, contributor, 'doc')
    success_message = url+" was successfully indexed."
    messages.append(success_message)
    return messages
